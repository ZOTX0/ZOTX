<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ZOTX</title>
<!-- Include Font Awesome CSS -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
<style>
    body {
        background: linear-gradient(to bottom right, #1c4eb5, #b368df);
        margin: 0;
        padding: 0;
        height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
        font-family: Arial, sans-serif;
        color: #fff; /* Text color for better contrast */
    }
    /* Additional styling for content */
    .content {
        text-align: center;
    }
    .social-icons {
        margin-top: 20px;
    }
    .social-icons a {
        display: inline-block;
        margin-right: 10px;
        font-size: 24px;
        color: #fff;
    }
    /* Styles from the second document */
    html {
        color-scheme: light dark;
        font-family:
          system-ui,
          -apple-system,
          BlinkMacSystemFont,
          'Segoe UI',
          Roboto,
          Oxygen,
          Ubuntu,
          Cantarell,
          'Open Sans',
          'Helvetica Neue',
          sans-serif;
        background: white;
        color: black;
    }
    body,
    h1,
    h2 {
        margin: 0;
    }
    h1,
    h2 {
        font-weight: 400;
    }
    h1 {
        font-size: 1.5rem;
        grid-column: 1 / -1;
    }
    h2 {
        font-size: 1rem;
        margin-bottom: 0.5rem;
    }
    video {
        width: 100%;
    }
    .grid {
        display: grid;
        grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
        gap: 1rem;
    }
    @media (max-width: 500px) {
        .grid {
          grid-template-columns: minmax(0, 1fr);
        }
    }
</style>
</head>
<body>
<div class="content">
    <h1>Hey, I'm ZOTX</h1>
    <h2>About me</h2>
    <p>I am a PC nerd.</p>
    <h2>What I'm working on</h2>
    <p>Working on the first 100% Egyptian built PC case.</p>
    <div class="social-icons">
        <a href="https://www.instagram.com/zotx60/" target="_blank"><i class="fab fa-instagram"></i></a>
        <a href="https://www.youtube.com/@ZOTX" target="_blank"><i class="fab fa-youtube"></i></a>
        <a href="https://discord.com/users/508428720172957707" target="_blank"><i class="fab fa-discord"></i></a>
        <a href="https://steamcommunity.com/id/ZOTX/" target="_blank"><i class="fab fa-steam"></i></a>
        <!-- Add more social media links as needed -->
    </div>
</div>
<!-- Paste the content of the second HTML document here -->
<div class="grid">
    <h1>Calls Echo Demo</h1>
    <div>
        <h2>Local stream</h2>
        <video id="local-video" autoplay muted></video>
    </div>
    <div>
        <h2>Remote echo stream</h2>
        <video id="remote-video" autoplay></video>
    </div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/webrtc-adapter/8.1.2/adapter.min.js" integrity="sha512-l40eBFtXx+ve5RryIELC3y6/OM6Nu89mLGQd7fg1C93tN6XrkC3supb+/YiD/Y+B8P37kdJjtG1MT1kOO2VzxA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script type="module">
    // JavaScript code from the second document
    const appId = '43dd5c89b133d3a765490f9b2223f6a6';
    const appSecret = 'abe42bb999d40d507699a144e41da324b9fa60499c451c9e8ddc811e377ee17f';

    class CallsApp {
        constructor(appId, basePath = 'https://rtc.live.cloudflare.com/v1') {
            this.prefixPath = `${basePath}/apps/${appId}`;
        }
        async sendRequest(url, body, method = 'POST') {
            const request = {
                method: method,
                mode: 'cors',
                headers: {
                    'content-type': 'application/json',
                    Authorization: `Bearer ${appSecret}`
                },
                body: JSON.stringify(body)
            };
            const response = await fetch(url, request);
            const result = await response.json();
            return result;
        }
        checkErrors(result, tracksCount = 0) {
            if (result.errorCode) {
                throw new Error(result.errorDescription);
            }
            for (let i = 0; i < tracksCount; i++) {
                if (result.tracks[i].errorCode) {
                    throw new Error(
                        `tracks[${i}]: ${result.tracks[i].errorDescription}`
                    );
                }
            }
        }
        async newSession(offerSDP) {
            const url = `${this.prefixPath}/sessions/new`;
            const body = {
                sessionDescription: {
                    type: 'offer',
                    sdp: offerSDP
                }
            };
            const result = await this.sendRequest(url, body);
            this.checkErrors(result);
            this.sessionId = result.sessionId;
            return result;
        }
        async newTracks(trackObjects, offerSDP = null) {
            const url = `${this.prefixPath}/sessions/${this.sessionId}/tracks/new`;
            const body = {
                sessionDescription: {
                    type: 'offer',
                    sdp: offerSDP
                },
                tracks: trackObjects
            };
            if (!offerSDP) {
                delete body['sessionDescription'];
            }
            const result = await this.sendRequest(url, body);
            this.checkErrors(result, trackObjects.length);
            return result;
        }
        async sendAnswerSDP(answer) {
            const url = `${this.prefixPath}/sessions/${this.sessionId}/renegotiate`;
            const body = {
                sessionDescription: {
                    type: 'answer',
                    sdp: answer
                }
            };
            const result = await this.sendRequest(url, body, 'PUT');
            this.checkErrors(result);
        }
    }

    self.pc = new RTCPeerConnection({
        iceServers: [
            {
                urls: 'stun:stun.cloudflare.com:3478'
            }
        ],
        bundlePolicy: 'max-bundle'
    });

    const localStream = await navigator.mediaDevices.getUserMedia({
        video: true,
        audio: true
    });

    const localVideoElement = document.getElementById('local-video');
    localVideoElement.srcObject = localStream;

    self.transceivers = localStream.getTracks().map(track =>
        self.pc.addTransceiver(track, {
            direction: 'sendonly'
        })
    );

    self.app = new CallsApp(appId);

    await self.pc.setLocalDescription(await self.pc.createOffer());
    const newSessionResult = await self.app.newSession(
        self.pc.localDescription.sdp
    );
    await self.pc.setRemoteDescription(
        new RTCSessionDescription(newSessionResult.sessionDescription)
    );

    await new Promise((resolve, reject) => {
        self.pc.addEventListener('iceconnectionstatechange', ev => {
            if (ev.target.iceConnectionState === 'connected') {
                resolve();
            }
            setTimeout(reject, 5000, 'connect timeout');
        });
    });

    let trackObjects = self.transceivers.map(transceiver => {
        return {
            location: 'local',
            mid: transceiver.mid,
            trackName: transceiver.sender.track.id
        };
    });

    await self.pc.setLocalDescription(await self.pc.createOffer());
    const newLocalTracksResult = await self.app.newTracks(
        trackObjects,
        self.pc.localDescription.sdp
    );
    await self.pc.setRemoteDescription(
        new RTCSessionDescription(newLocalTracksResult.sessionDescription)
    );

    trackObjects = trackObjects.map(trackObject => {
        return {
            location: 'remote',
            sessionId: self.app.sessionId,
            trackName: trackObject.trackName
        };
    });

    const remoteTracksPromise = new Promise(resolve => {
        let tracks = [];
        self.pc.ontrack = event => {
            tracks.push(event.track);
            console.debug(`Got track mid=${event.track.mid}`);
            if (tracks.length >= 2) {
                resolve(tracks);
            }
        };
    });

    const newRemoteTracksResult = await self.app.newTracks(trackObjects);
    if (newRemoteTracksResult.requiresImmediateRenegotiation) {
        switch (newRemoteTracksResult.sessionDescription.type) {
            case 'offer':
                await self.pc.setRemoteDescription(
                    new RTCSessionDescription(
                        newRemoteTracksResult.sessionDescription
                    )
                );
                await self.pc.setLocalDescription(await self.pc.createAnswer());
                await self.app.sendAnswerSDP(self.pc.localDescription.sdp);
                break;
            case 'answer':
                throw new Error('An offer SDP was expected');
        }
    }

    const remoteTracks = await remoteTracksPromise;
    const remoteVideoElement = document.getElementById('remote-video');
    const remoteStream = new MediaStream();
    remoteStream.addTrack(remoteTracks[0]);
    remoteStream.addTrack(remoteTracks[1]);
    remoteVideoElement.srcObject = remoteStream;
</script>
</body>
</html>
